"""
MODULE 2.2: Multi-Agent System with LangGraph (DeepAgents Concepts)
===================================================================

Demonstrates the same concepts as DeepAgents using LangGraph directly:
1. Supervisor agent with specialized sub-agents (research, analysis, writing)
2. Visible TODO list tracking
3. Full action logging for supervisor and sub-agents
4. Multi-step task delegation and synthesis

Note: This is a Python 3.9-compatible version using LangGraph.
DeepAgents requires Python 3.11+.

Based on: langchain-langgraph-hands-on-guide.md Module 2.2
"""

import os
from typing import Annotated, TypedDict, Literal
from dotenv import load_dotenv

# LangGraph imports
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.checkpoint.memory import MemorySaver

# LangChain imports
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain_core.tools import tool

load_dotenv()

# ============================================================================
# CONFIGURATION
# ============================================================================

MODEL_CONFIG = {
    "model": "anthropic/claude-haiku-4.5",  # Fast model for demo
    "openai_api_base": "https://openrouter.ai/api/v1",
    "openai_api_key": os.getenv("OPENROUTER_API_KEY"),
    "temperature": 0.7,
}

print("\n" + "=" * 80)
print("MODULE 2.2: Multi-Agent Research System (LangGraph Implementation)")
print("=" * 80)

# ============================================================================
# CUSTOM TOOLS
# ============================================================================

@tool
def web_search(query: str) -> str:
    """Search the web for information (simulated)."""
    results = {
        "langchain": "LangChain is a framework for developing applications powered by language models. v1.0 released October 2025 with major architectural improvements.",
        "langgraph": "LangGraph is a library for building stateful, multi-actor applications with LLMs. Latest version: v1.0.1. Features state machines, checkpointing, and human-in-the-loop.",
        "deepagents": "DeepAgents v0.2 released October 28, 2025. Major features: pluggable backends (State, Store, Filesystem, Composite), auto result eviction, conversation summarization.",
    }

    for key, value in results.items():
        if key.lower() in query.lower():
            return f"ğŸ” Search: '{query}'\n\n{value}"

    return f"ğŸ” Search: '{query}'\n\nGeneral information about AI frameworks and development tools."


@tool
def analyze_data(data: str) -> str:
    """Analyze data and extract insights."""
    word_count = len(data.split())
    lines = data.split('\n')

    return f"""ğŸ“Š Analysis Complete:
- Total words: {word_count}
- Total lines: {len(lines)}
- Key topics detected: AI frameworks, software development
- Quality assessment: Comprehensive technical information
- Recommendation: Suitable for technical documentation"""


@tool
def format_document(content: str) -> str:
    """Format content into structured markdown document."""
    return f"""# Research Report

## Executive Summary
{content[:200]}...

## Detailed Findings
{content}

## Conclusion
Research and analysis completed successfully.

---
*Generated by Multi-Agent Research System*
*Powered by LangGraph v1.0.1*
"""


# ============================================================================
# STATE DEFINITION
# ============================================================================

class AgentState(TypedDict):
    """State for the multi-agent system."""
    messages: Annotated[list, add_messages]  # Conversation history
    todos: list[dict]  # TODO list tracking
    next_action: str  # Routing decision
    research_data: str  # Data from research agent
    analysis_data: str  # Data from analysis agent


# ============================================================================
# TODO LIST MANAGEMENT
# ============================================================================

def create_todos(task: str) -> list[dict]:
    """Create TODO list based on task complexity."""
    if "compare" in task.lower() or "report" in task.lower():
        return [
            {"content": "Research required information", "status": "pending"},
            {"content": "Analyze gathered data", "status": "pending"},
            {"content": "Write formatted report", "status": "pending"},
            {"content": "Review and synthesize results", "status": "pending"},
        ]
    elif "research" in task.lower():
        return [
            {"content": "Search for information", "status": "pending"},
            {"content": "Compile findings", "status": "pending"},
        ]
    else:
        return [
            {"content": "Process user request", "status": "pending"},
        ]


def update_todo_status(todos: list[dict], index: int, status: str) -> list[dict]:
    """Update status of a specific TODO."""
    if 0 <= index < len(todos):
        todos[index]["status"] = status
    return todos


def display_todos(todos: list[dict]) -> str:
    """Format TODO list for display."""
    if not todos:
        return ""

    output = ["\n" + "=" * 80, "ğŸ“ TODO LIST", "=" * 80]
    for i, todo in enumerate(todos, 1):
        status_icon = {
            "pending": "â³",
            "in_progress": "ğŸ”„",
            "completed": "âœ…"
        }.get(todo["status"], "â“")
        output.append(f"{i}. {status_icon} [{todo['status'].upper()}] {todo['content']}")
    output.append("=" * 80)
    return "\n".join(output)


# ============================================================================
# AGENT NODES
# ============================================================================

def supervisor_node(state: AgentState) -> dict:
    """Supervisor agent that coordinates the workflow."""
    print("\n" + "â”€" * 80)
    print("ğŸ‘” [SUPERVISOR] Analyzing request...")

    user_message = state["messages"][-1].content if state["messages"] else ""

    # Create TODO list if not exists
    todos = state.get("todos", [])
    if not todos:
        todos = create_todos(user_message)
        print(display_todos(todos))

    # Determine next action based on request and current state
    research_done = bool(state.get("research_data"))
    analysis_done = bool(state.get("analysis_data"))

    if not research_done:
        next_action = "research"
        todos = update_todo_status(todos, 0, "in_progress")
    elif not analysis_done:
        next_action = "analyze"
        todos = update_todo_status(todos, 0, "completed")
        todos = update_todo_status(todos, 1, "in_progress")
    else:
        next_action = "write"
        todos = update_todo_status(todos, 1, "completed")
        todos = update_todo_status(todos, 2, "in_progress")

    print(f"ğŸ’­ [SUPERVISOR] Decision: Delegate to {next_action} agent")

    return {
        "todos": todos,
        "next_action": next_action,
    }


def research_agent_node(state: AgentState) -> dict:
    """Research specialist agent."""
    print("\n" + "â”€" * 80)
    print("ğŸ”¬ [RESEARCHER] Starting research task...")

    user_query = state["messages"][-1].content if state["messages"] else ""

    # Extract research topics
    print(f"ğŸ“‹ [RESEARCHER] Query: {user_query[:100]}...")

    # Perform searches
    results = []
    topics = ["langchain", "langgraph", "deepagents"]
    for topic in topics:
        if topic in user_query.lower():
            print(f"ğŸ”§ [RESEARCHER] Using tool: web_search")
            print(f"   Args: {{'query': '{topic}'}}")
            result = web_search.invoke({"query": topic})
            results.append(result)
            print(f"âœ… [RESEARCHER] Found data on {topic}")

    research_data = "\n\n".join(results) if results else web_search.invoke({"query": user_query})

    print(f"ğŸ’¾ [RESEARCHER] Compiled {len(results)} research findings")

    return {
        "research_data": research_data,
        "messages": [AIMessage(content=f"Research complete. Gathered information on {len(results)} topics.")],
    }


def analysis_agent_node(state: AgentState) -> dict:
    """Analysis specialist agent."""
    print("\n" + "â”€" * 80)
    print("ğŸ“Š [ANALYST] Starting data analysis...")

    research_data = state.get("research_data", "")

    if not research_data:
        print("âš ï¸  [ANALYST] No research data available")
        return {"analysis_data": "No data to analyze"}

    print(f"ğŸ“‹ [ANALYST] Analyzing {len(research_data)} characters of research data")
    print("ğŸ”§ [ANALYST] Using tool: analyze_data")

    analysis_result = analyze_data.invoke({"data": research_data})

    print("âœ… [ANALYST] Analysis complete")
    print(f"ğŸ’¡ [ANALYST] Key insights extracted")

    return {
        "analysis_data": analysis_result,
        "messages": [AIMessage(content="Analysis complete. Key insights identified.")],
    }


def writing_agent_node(state: AgentState) -> dict:
    """Writing specialist agent."""
    print("\n" + "â”€" * 80)
    print("âœï¸  [WRITER] Creating formatted document...")

    research_data = state.get("research_data", "")
    analysis_data = state.get("analysis_data", "")

    content = f"{research_data}\n\n{analysis_data}"

    print("ğŸ“‹ [WRITER] Compiling research and analysis")
    print("ğŸ”§ [WRITER] Using tool: format_document")

    formatted_doc = format_document.invoke({"content": content})

    print("âœ… [WRITER] Document formatted")
    print(f"ğŸ“„ [WRITER] Generated {len(formatted_doc)} character report")

    # Mark writing task as complete
    todos = state.get("todos", [])
    todos = update_todo_status(todos, 2, "completed")
    todos = update_todo_status(todos, 3, "in_progress")

    return {
        "todos": todos,
        "messages": [AIMessage(content=formatted_doc)],
        "next_action": "end",
    }


def synthesize_node(state: AgentState) -> dict:
    """Supervisor synthesizes final response."""
    print("\n" + "â”€" * 80)
    print("ğŸ¯ [SUPERVISOR] Synthesizing final response...")

    # Mark all tasks as complete
    todos = state.get("todos", [])
    for i in range(len(todos)):
        todos = update_todo_status(todos, i, "completed")

    print(display_todos(todos))

    last_message = state["messages"][-1].content if state["messages"] else "Task completed"

    print("âœ… [SUPERVISOR] Multi-agent workflow complete")

    return {
        "todos": todos,
        "messages": [AIMessage(content=f"âœ¨ Research complete!\n\n{last_message}")],
    }


# ============================================================================
# ROUTING LOGIC
# ============================================================================

def route_next_step(state: AgentState) -> Literal["research", "analyze", "write", "end"]:
    """Determine which agent should act next."""
    next_action = state.get("next_action", "research")

    if next_action == "end":
        return "end"

    return next_action


# ============================================================================
# BUILD GRAPH
# ============================================================================

print("\nğŸ—ï¸  Building Multi-Agent Workflow Graph...")

workflow = StateGraph(AgentState)

# Add nodes
workflow.add_node("supervisor", supervisor_node)
workflow.add_node("research", research_agent_node)
workflow.add_node("analyze", analysis_agent_node)
workflow.add_node("write", writing_agent_node)
workflow.add_node("synthesize", synthesize_node)

# Define edges
workflow.add_edge(START, "supervisor")
workflow.add_conditional_edges(
    "supervisor",
    route_next_step,
    {
        "research": "research",
        "analyze": "analyze",
        "write": "write",
        "end": "synthesize",
    }
)
workflow.add_edge("research", "supervisor")
workflow.add_edge("analyze", "supervisor")
workflow.add_edge("write", "synthesize")
workflow.add_edge("synthesize", END)

# Compile
app = workflow.compile(checkpointer=MemorySaver())

print("âœ… Multi-Agent System Ready")
print("   - Supervisor: Coordinates workflow")
print("   - Researcher: Searches for information")
print("   - Analyst: Extracts insights")
print("   - Writer: Creates formatted documents")

# ============================================================================
# RUN EXAMPLES
# ============================================================================

def run_multi_agent_task(query: str):
    """Execute multi-agent workflow."""
    print("\n\n" + "ğŸ¯" * 40)
    print(f"USER QUERY: {query}")
    print("ğŸ¯" * 40)

    config = {"configurable": {"thread_id": "demo-session"}}

    result = app.invoke(
        {
            "messages": [HumanMessage(content=query)],
            "todos": [],
            "next_action": "",
            "research_data": "",
            "analysis_data": "",
        },
        config=config
    )

    # Display final result
    print("\n" + "=" * 80)
    print("ğŸ“Š FINAL RESULT")
    print("=" * 80)
    print(result["messages"][-1].content)
    print("=" * 80)

    return result


# Example 1: Simple research
print("\n\n" + "ğŸ”¬" * 40)
print("EXAMPLE 1: Simple Research Task")
print("ğŸ”¬" * 40)

run_multi_agent_task("Research LangChain v1.0")

# Example 2: Complex multi-step
print("\n\n" + "ğŸ”¬" * 40)
print("EXAMPLE 2: Complex Multi-Step Task")
print("ğŸ”¬" * 40)

run_multi_agent_task(
    "Research LangChain v1.0, LangGraph v1.0.1, and DeepAgents v0.2. Compare their features and create a technical report."
)

# ============================================================================
# SUMMARY
# ============================================================================

print("\n\n" + "=" * 80)
print("MODULE 2.2 SUMMARY")
print("=" * 80)

summary = """
âœ… Demonstrated Concepts (LangGraph Implementation):

1. Multi-Agent Architecture:
   âœ“ Supervisor agent coordinates workflow
   âœ“ 3 specialized sub-agents (research, analysis, writing)
   âœ“ Clear delegation and routing logic

2. Visibility & Observability:
   âœ“ TODO list tracking (create_todos, update_todo_status)
   âœ“ Detailed logging for each agent's actions
   âœ“ All tool calls and decisions visible

3. State Management:
   âœ“ Shared state across all agents
   âœ“ State updates track progress
   âœ“ Checkpointing for conversation memory

4. Workflow Orchestration:
   âœ“ Conditional routing between agents
   âœ“ Sequential task execution
   âœ“ Final synthesis step

ğŸ“š DeepAgents Equivalents:

LangGraph Pattern â†’ DeepAgents v0.2 Feature
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
StateGraph nodes â†’ create_deep_agent() with subagents
Custom TODO logic â†’ TodoListMiddleware (automatic)
Manual delegation â†’ SubAgentMiddleware with 'task' tool
State persistence â†’ Pluggable backends (State, Store, Filesystem)
Custom logging â†’ Middleware architecture

ğŸ¯ To Use Real DeepAgents (Python 3.11+):

1. Upgrade Python: brew install python@3.11
2. Install: pip install deepagents
3. Use the original module-2-2.py file

ğŸ“– Key Learnings:

- Multi-agent systems enable specialized expertise
- TODO lists help track complex workflows
- State management critical for coordination
- Routing logic determines workflow flow
- LangGraph provides foundational patterns
- DeepAgents simplifies with middleware/backends
"""

print(summary)
print("=" * 80)

print("\nâœ¨ Module 2.2 Complete! âœ¨")
print("\nNote: This demo uses LangGraph directly (Python 3.9 compatible)")
print("For production, upgrade to Python 3.11+ and use DeepAgents v0.2\n")
